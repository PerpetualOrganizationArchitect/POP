// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Script.sol";
import "forge-std/console.sol";

import {OrgDeployer} from "../src/OrgDeployer.sol";
import {IHybridVotingInit} from "../src/libs/ModuleDeploymentLib.sol";
import {RoleConfigStructs} from "../src/libs/RoleConfigStructs.sol";

/**
 * @title DeployOrg
 * @notice Deploys a new organization from JSON configuration
 * @dev Reads infrastructure addresses and org config, then deploys via OrgDeployer
 *
 * Usage:
 *   forge script script/DeployOrg.s.sol:DeployOrg \
 *     --rpc-url $RPC_URL \
 *     --broadcast
 *
 * Environment Variables Required:
 *   - ORG_DEPLOYER_ADDRESS: Address of deployed OrgDeployer contract
 *   - GLOBAL_ACCOUNT_REGISTRY: Address of global UniversalAccountRegistry
 *   - ORG_CONFIG_PATH: Path to org config JSON file (default: script/org-config-example.json)
 *   - DEPLOYER_PRIVATE_KEY: Private key for deployment
 */
contract DeployOrg is Script {
    /*═══════════════════════════ STRUCTS ═══════════════════════════*/

    // JSON parsing structs - must match org config JSON structure
    struct OrgConfigJson {
        string orgId;
        string orgName;
        bool autoUpgrade;
        QuorumConfig quorum;
        RoleConfig[] roles;
        VotingClassConfig[] votingClasses;
        RoleAssignmentsConfig roleAssignments;
        address[] ddInitialTargets;
        bool withPaymaster;
    }

    struct QuorumConfig {
        uint8 hybrid;
        uint8 directDemocracy;
    }

    struct RoleVouchingConfigJson {
        bool enabled;
        uint32 quorum;
        uint256 voucherRoleIndex;
        bool combineWithHierarchy;
    }

    struct RoleEligibilityDefaultsJson {
        bool eligible;
        bool standing;
    }

    struct RoleHierarchyConfigJson {
        uint256 adminRoleIndex;
    }

    struct RoleDistributionConfigJson {
        bool mintToDeployer;
        bool mintToExecutor;
        address[] additionalWearers;
    }

    struct HatConfigJson {
        uint32 maxSupply;
        bool mutableHat;
    }

    struct RoleConfig {
        string name;
        string image;
        bool canVote;
        RoleVouchingConfigJson vouching;
        RoleEligibilityDefaultsJson defaults;
        RoleHierarchyConfigJson hierarchy;
        RoleDistributionConfigJson distribution;
        HatConfigJson hatConfig;
    }

    struct VotingClassConfig {
        string strategy;
        uint8 slicePct;
        bool quadratic;
        uint256 minBalance;
        address asset;
        uint256[] hatIds;
    }

    struct RoleAssignmentsConfig {
        uint256[] quickJoinRoles;
        uint256[] tokenMemberRoles;
        uint256[] tokenApproverRoles;
        uint256[] taskCreatorRoles;
        uint256[] educationCreatorRoles;
        uint256[] educationMemberRoles;
        uint256[] hybridProposalCreatorRoles;
        uint256[] ddVotingRoles;
        uint256[] ddCreatorRoles;
    }

    /*═══════════════════════════ MAIN DEPLOYMENT ═══════════════════════════*/

    function run() public {
        // Read infrastructure addresses from JSON file (auto-generated by infrastructure deployment)
        string memory infraJson = vm.readFile("script/infrastructure.json");
        address orgDeployerAddr = vm.parseJsonAddress(infraJson, ".orgDeployer");
        address globalAccountRegistry = vm.parseJsonAddress(infraJson, ".globalAccountRegistry");

        require(orgDeployerAddr != address(0), "infrastructure.json not found or invalid - deploy infrastructure first");
        require(globalAccountRegistry != address(0), "infrastructure.json missing globalAccountRegistry");

        // Get org config path (default to example)
        string memory configPath = vm.envOr("ORG_CONFIG_PATH", string("script/org-config-example.json"));

        uint256 deployerPrivateKey = vm.envUint("DEPLOYER_PRIVATE_KEY");
        address deployer = vm.addr(deployerPrivateKey);

        console.log("\n=== Starting POA Organization Deployment ===");
        console.log("Deployer:", deployer);
        console.log("OrgDeployer:", orgDeployerAddr);
        console.log("GlobalAccountRegistry:", globalAccountRegistry);
        console.log("Config Path:", configPath);

        // Read and parse org config
        string memory configJson = vm.readFile(configPath);
        OrgConfigJson memory config = _parseOrgConfig(configJson);

        console.log("\nOrganization Config:");
        console.log("  ID:", config.orgId);
        console.log("  Name:", config.orgName);
        console.log("  Auto Upgrade:", config.autoUpgrade);
        console.log("  Roles:", config.roles.length);
        console.log("  Voting Classes:", config.votingClasses.length);

        // Build deployment params (deployer will receive ADMIN hat)
        OrgDeployer.DeploymentParams memory params = _buildDeploymentParams(config, globalAccountRegistry, deployer);

        // Deploy organization
        vm.startBroadcast(deployerPrivateKey);

        OrgDeployer orgDeployer = OrgDeployer(orgDeployerAddr);

        OrgDeployer.DeploymentResult memory result;

        if (config.withPaymaster) {
            console.log("\nDeploying org WITH paymaster...");
            // Note: Paymaster deployment requires additional bytecode parameter
            // For now, deploy without paymaster. Add paymaster support as needed.
            result = orgDeployer.deployFullOrg(params);
            console.log("Warning: Paymaster deployment not yet implemented in script");
        } else {
            console.log("\nDeploying org...");
            result = orgDeployer.deployFullOrg(params);
        }

        vm.stopBroadcast();

        // Output deployment results
        _outputDeployment(config, result);

        console.log("\n=== Organization Deployment Complete ===\n");
    }

    /*═══════════════════════════ CONFIG PARSING ═══════════════════════════*/

    function _parseOrgConfig(string memory configJson) internal returns (OrgConfigJson memory config) {
        // Parse top-level fields
        config.orgId = vm.parseJsonString(configJson, ".orgId");
        config.orgName = vm.parseJsonString(configJson, ".orgName");
        config.autoUpgrade = vm.parseJsonBool(configJson, ".autoUpgrade");
        config.withPaymaster = vm.parseJsonBool(configJson, ".withPaymaster");

        // Parse quorum
        config.quorum.hybrid = uint8(vm.parseJsonUint(configJson, ".quorum.hybrid"));
        config.quorum.directDemocracy = uint8(vm.parseJsonUint(configJson, ".quorum.directDemocracy"));

        // Parse roles array - use serializeJson to work around struct array limitations
        // First, manually count by trying to parse until we fail (reasonable max: 100)
        uint256 rolesLength = 0;
        for (uint256 i = 0; i < 100; i++) {
            try vm.parseJsonString(configJson, string.concat(".roles[", vm.toString(i), "].name")) returns (
                string memory
            ) {
                rolesLength++;
            } catch {
                break;
            }
        }

        config.roles = new RoleConfig[](rolesLength);
        for (uint256 i = 0; i < rolesLength; i++) {
            string memory basePath = string.concat(".roles[", vm.toString(i), "]");
            config.roles[i].name = vm.parseJsonString(configJson, string.concat(basePath, ".name"));
            config.roles[i].image = vm.parseJsonString(configJson, string.concat(basePath, ".image"));
            config.roles[i].canVote = vm.parseJsonBool(configJson, string.concat(basePath, ".canVote"));

            // Parse nested vouching config (optional - use try/catch for backwards compat)
            try vm.parseJsonBool(configJson, string.concat(basePath, ".vouching.enabled")) returns (bool enabled) {
                config.roles[i].vouching.enabled = enabled;
                config.roles[i].vouching.quorum =
                    uint32(vm.parseJsonUint(configJson, string.concat(basePath, ".vouching.quorum")));
                config.roles[i].vouching.voucherRoleIndex =
                    vm.parseJsonUint(configJson, string.concat(basePath, ".vouching.voucherRoleIndex"));
                config.roles[i].vouching.combineWithHierarchy =
                    vm.parseJsonBool(configJson, string.concat(basePath, ".vouching.combineWithHierarchy"));
            } catch {}

            // Parse nested defaults config (optional)
            try vm.parseJsonBool(configJson, string.concat(basePath, ".defaults.eligible")) returns (bool eligible) {
                config.roles[i].defaults.eligible = eligible;
                config.roles[i].defaults.standing =
                    vm.parseJsonBool(configJson, string.concat(basePath, ".defaults.standing"));
            } catch {
                // Default to eligible=true, standing=true for backwards compat
                config.roles[i].defaults.eligible = true;
                config.roles[i].defaults.standing = true;
            }

            // Parse nested hierarchy config (optional)
            try vm.parseJsonUint(configJson, string.concat(basePath, ".hierarchy.adminRoleIndex")) returns (
                uint256 adminIdx
            ) {
                config.roles[i].hierarchy.adminRoleIndex = adminIdx;
            } catch {
                // Default to type(uint256).max for backwards compat
                config.roles[i].hierarchy.adminRoleIndex = type(uint256).max;
            }

            // Parse nested distribution config (optional)
            try vm.parseJsonBool(configJson, string.concat(basePath, ".distribution.mintToDeployer")) returns (
                bool mintToDeployer
            ) {
                config.roles[i].distribution.mintToDeployer = mintToDeployer;
                config.roles[i].distribution.mintToExecutor =
                    vm.parseJsonBool(configJson, string.concat(basePath, ".distribution.mintToExecutor"));
                bytes memory additionalWearersData =
                    vm.parseJson(configJson, string.concat(basePath, ".distribution.additionalWearers"));
                config.roles[i].distribution.additionalWearers = abi.decode(additionalWearersData, (address[]));
            } catch {}

            // Parse nested hatConfig (optional)
            try vm.parseJsonUint(configJson, string.concat(basePath, ".hatConfig.maxSupply")) returns (
                uint256 maxSupply
            ) {
                config.roles[i].hatConfig.maxSupply = uint32(maxSupply);
                config.roles[i].hatConfig.mutableHat =
                    vm.parseJsonBool(configJson, string.concat(basePath, ".hatConfig.mutableHat"));
            } catch {
                // Default to unlimited and mutable for backwards compat
                config.roles[i].hatConfig.maxSupply = type(uint32).max;
                config.roles[i].hatConfig.mutableHat = true;
            }
        }

        // Parse voting classes array (reasonable max: 100)
        uint256 votingClassesLength = 0;
        for (uint256 i = 0; i < 100; i++) {
            try vm.parseJsonString(configJson, string.concat(".votingClasses[", vm.toString(i), "].strategy")) returns (
                string memory
            ) {
                votingClassesLength++;
            } catch {
                break;
            }
        }

        config.votingClasses = new VotingClassConfig[](votingClassesLength);
        for (uint256 i = 0; i < votingClassesLength; i++) {
            string memory basePath = string.concat(".votingClasses[", vm.toString(i), "]");
            config.votingClasses[i].strategy = vm.parseJsonString(configJson, string.concat(basePath, ".strategy"));
            config.votingClasses[i].slicePct = uint8(vm.parseJsonUint(configJson, string.concat(basePath, ".slicePct")));
            config.votingClasses[i].quadratic = vm.parseJsonBool(configJson, string.concat(basePath, ".quadratic"));
            config.votingClasses[i].minBalance = vm.parseJsonUint(configJson, string.concat(basePath, ".minBalance"));
            config.votingClasses[i].asset = vm.parseJsonAddress(configJson, string.concat(basePath, ".asset"));

            // Parse hatIds array
            bytes memory hatIdsData = vm.parseJson(configJson, string.concat(basePath, ".hatIds"));
            config.votingClasses[i].hatIds = abi.decode(hatIdsData, (uint256[]));
        }

        // Parse role assignments
        bytes memory quickJoinData = vm.parseJson(configJson, ".roleAssignments.quickJoinRoles");
        config.roleAssignments.quickJoinRoles = abi.decode(quickJoinData, (uint256[]));

        bytes memory tokenMemberData = vm.parseJson(configJson, ".roleAssignments.tokenMemberRoles");
        config.roleAssignments.tokenMemberRoles = abi.decode(tokenMemberData, (uint256[]));

        bytes memory tokenApproverData = vm.parseJson(configJson, ".roleAssignments.tokenApproverRoles");
        config.roleAssignments.tokenApproverRoles = abi.decode(tokenApproverData, (uint256[]));

        bytes memory taskCreatorData = vm.parseJson(configJson, ".roleAssignments.taskCreatorRoles");
        config.roleAssignments.taskCreatorRoles = abi.decode(taskCreatorData, (uint256[]));

        bytes memory educationCreatorData = vm.parseJson(configJson, ".roleAssignments.educationCreatorRoles");
        config.roleAssignments.educationCreatorRoles = abi.decode(educationCreatorData, (uint256[]));

        bytes memory educationMemberData = vm.parseJson(configJson, ".roleAssignments.educationMemberRoles");
        config.roleAssignments.educationMemberRoles = abi.decode(educationMemberData, (uint256[]));

        bytes memory hybridProposalData = vm.parseJson(configJson, ".roleAssignments.hybridProposalCreatorRoles");
        config.roleAssignments.hybridProposalCreatorRoles = abi.decode(hybridProposalData, (uint256[]));

        bytes memory ddVotingData = vm.parseJson(configJson, ".roleAssignments.ddVotingRoles");
        config.roleAssignments.ddVotingRoles = abi.decode(ddVotingData, (uint256[]));

        bytes memory ddCreatorData = vm.parseJson(configJson, ".roleAssignments.ddCreatorRoles");
        config.roleAssignments.ddCreatorRoles = abi.decode(ddCreatorData, (uint256[]));

        // Parse DD initial targets
        bytes memory ddTargetsData = vm.parseJson(configJson, ".ddInitialTargets");
        config.ddInitialTargets = abi.decode(ddTargetsData, (address[]));

        return config;
    }

    /*═══════════════════════════ PARAM BUILDING ═══════════════════════════*/

    /**
     * @notice Convert array of role indices to bitmap
     * @dev Each bit represents a role index (bit N = role N)
     * @param roles Array of role indices
     * @return bitmap Bitmap representation where bit N is set if role N is in array
     */
    function _roleArrayToBitmap(uint256[] memory roles) internal pure returns (uint256 bitmap) {
        for (uint256 i = 0; i < roles.length; i++) {
            require(roles[i] < 256, "Role index must be < 256");
            bitmap |= (1 << roles[i]);
        }
    }

    function _buildDeploymentParams(OrgConfigJson memory config, address globalAccountRegistry, address deployerAddress)
        internal
        view
        returns (OrgDeployer.DeploymentParams memory params)
    {
        // Set basic params
        params.orgId = keccak256(bytes(config.orgId));
        params.orgName = config.orgName;
        params.metadataHash = bytes32(0); // No metadata hash by default (can be set via env)
        params.registryAddr = globalAccountRegistry;
        params.deployerAddress = deployerAddress; // Address to receive ADMIN hat
        params.deployerUsername = vm.envOr("DEPLOYER_USERNAME", string("")); // Optional username (empty = skip)
        params.autoUpgrade = config.autoUpgrade;
        params.hybridQuorumPct = config.quorum.hybrid;
        params.ddQuorumPct = config.quorum.directDemocracy;
        params.ddInitialTargets = config.ddInitialTargets;

        // Build role configs
        params.roles = new RoleConfigStructs.RoleConfig[](config.roles.length);

        for (uint256 i = 0; i < config.roles.length; i++) {
            RoleConfig memory role = config.roles[i];

            params.roles[i] = RoleConfigStructs.RoleConfig({
                name: role.name,
                image: role.image,
                metadataCID: bytes32(0), // TODO: Add to JSON config when needed
                canVote: role.canVote,
                vouching: RoleConfigStructs.RoleVouchingConfig({
                    enabled: role.vouching.enabled,
                    quorum: role.vouching.quorum,
                    voucherRoleIndex: role.vouching.voucherRoleIndex,
                    combineWithHierarchy: role.vouching.combineWithHierarchy
                }),
                defaults: RoleConfigStructs.RoleEligibilityDefaults({
                    eligible: role.defaults.eligible, standing: role.defaults.standing
                }),
                hierarchy: RoleConfigStructs.RoleHierarchyConfig({adminRoleIndex: role.hierarchy.adminRoleIndex}),
                distribution: RoleConfigStructs.RoleDistributionConfig({
                    mintToDeployer: role.distribution.mintToDeployer,
                    mintToExecutor: role.distribution.mintToExecutor,
                    additionalWearers: role.distribution.additionalWearers
                }),
                hatConfig: RoleConfigStructs.HatConfig({
                    maxSupply: role.hatConfig.maxSupply, mutableHat: role.hatConfig.mutableHat
                })
            });
        }

        // Build voting classes
        params.hybridClasses = new IHybridVotingInit.ClassConfig[](config.votingClasses.length);

        for (uint256 i = 0; i < config.votingClasses.length; i++) {
            VotingClassConfig memory vClass = config.votingClasses[i];

            IHybridVotingInit.ClassStrategy strategy;
            if (keccak256(bytes(vClass.strategy)) == keccak256(bytes("DIRECT"))) {
                strategy = IHybridVotingInit.ClassStrategy.DIRECT;
            } else if (keccak256(bytes(vClass.strategy)) == keccak256(bytes("ERC20_BAL"))) {
                strategy = IHybridVotingInit.ClassStrategy.ERC20_BAL;
            } else {
                revert("Invalid strategy: must be DIRECT or ERC20_BAL");
            }

            params.hybridClasses[i] = IHybridVotingInit.ClassConfig({
                strategy: strategy,
                slicePct: vClass.slicePct,
                quadratic: vClass.quadratic,
                minBalance: vClass.minBalance,
                asset: vClass.asset,
                hatIds: vClass.hatIds
            });
        }

        // Build role assignments (convert arrays to bitmaps)
        params.roleAssignments = OrgDeployer.RoleAssignments({
            quickJoinRolesBitmap: _roleArrayToBitmap(config.roleAssignments.quickJoinRoles),
            tokenMemberRolesBitmap: _roleArrayToBitmap(config.roleAssignments.tokenMemberRoles),
            tokenApproverRolesBitmap: _roleArrayToBitmap(config.roleAssignments.tokenApproverRoles),
            taskCreatorRolesBitmap: _roleArrayToBitmap(config.roleAssignments.taskCreatorRoles),
            educationCreatorRolesBitmap: _roleArrayToBitmap(config.roleAssignments.educationCreatorRoles),
            educationMemberRolesBitmap: _roleArrayToBitmap(config.roleAssignments.educationMemberRoles),
            hybridProposalCreatorRolesBitmap: _roleArrayToBitmap(config.roleAssignments.hybridProposalCreatorRoles),
            ddVotingRolesBitmap: _roleArrayToBitmap(config.roleAssignments.ddVotingRoles),
            ddCreatorRolesBitmap: _roleArrayToBitmap(config.roleAssignments.ddCreatorRoles)
        });

        return params;
    }

    /*═══════════════════════════ OUTPUT ═══════════════════════════*/

    function _outputDeployment(OrgConfigJson memory config, OrgDeployer.DeploymentResult memory result) internal view {
        console.log("\n--- Deployed Organization Addresses ---");
        console.log("{");
        console.log('  "orgId": "%s",', config.orgId);
        console.log('  "orgName": "%s",', config.orgName);
        console.log('  "contracts": {');
        console.log('    "executor": "%s",', result.executor);
        console.log('    "hybridVoting": "%s",', result.hybridVoting);
        console.log('    "directDemocracyVoting": "%s",', result.directDemocracyVoting);
        console.log('    "quickJoin": "%s",', result.quickJoin);
        console.log('    "participationToken": "%s",', result.participationToken);
        console.log('    "taskManager": "%s",', result.taskManager);
        console.log('    "educationHub": "%s",', result.educationHub);
        console.log('    "paymentManager": "%s"', result.paymentManager);
        console.log("  }");
        console.log("}");
    }
}
