// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test, console} from "forge-std/Test.sol";
import {PaymentManager} from "../src/PaymentManager.sol";
import {IPaymentManager} from "../src/interfaces/IPaymentManager.sol";
import {MockERC20} from "./mocks/MockERC20.sol";

contract DistributionVulnerabilityTest is Test {
    PaymentManager public paymentManager;
    MockERC20 public revenueShareToken;
    
    address public executor = address(0x1);
    address public alice = address(0x2);
    address public bob = address(0x3);
    address public charlie = address(0x4);
    address public newHolder = address(0x5); // New holder who mints after proposal
    
    function setUp() public {
        // Deploy revenue share token
        revenueShareToken = new MockERC20("Revenue Share", "REV");
        
        // Deploy payment manager
        paymentManager = new PaymentManager();
        paymentManager.initialize(executor, address(revenueShareToken));
        
        // Setup initial token distribution
        revenueShareToken.mint(alice, 500 * 1e18);  // 50%
        revenueShareToken.mint(bob, 300 * 1e18);    // 30%
        revenueShareToken.mint(charlie, 200 * 1e18); // 20%
        // Total: 1000 tokens
        
        // Fund the payment manager with ETH
        vm.deal(address(paymentManager), 10 ether);
    }
    
    function test_VulnerabilityMintAfterProposalCreation() public {
        console.log("=== Testing Distribution Vulnerability ===");
        console.log("Initial state:");
        console.log("- Total supply: %s", revenueShareToken.totalSupply());
        console.log("- Alice balance: %s", revenueShareToken.balanceOf(alice));
        console.log("- Bob balance: %s", revenueShareToken.balanceOf(bob));
        console.log("- Charlie balance: %s", revenueShareToken.balanceOf(charlie));
        console.log("- New holder balance: %s", revenueShareToken.balanceOf(newHolder));
        
        // Step 1: Create proposal with current holders array
        address[] memory holdersAtProposalTime = new address[](3);
        holdersAtProposalTime[0] = alice;
        holdersAtProposalTime[1] = bob;
        holdersAtProposalTime[2] = charlie;
        
        console.log("\n1. Proposal created with 3 holders (alice, bob, charlie)");
        console.log("   Holders array is now fixed in the proposal calldata");
        
        // Step 2: After proposal creation but before execution, mint tokens to new holder
        revenueShareToken.mint(newHolder, 100 * 1e18);
        
        console.log("\n2. After proposal creation, new holder receives tokens:");
        console.log("   - New holder balance: %s", revenueShareToken.balanceOf(newHolder));
        console.log("   - New total supply: %s", revenueShareToken.totalSupply());
        
        // Step 3: Execute distribution with the old holders array
        console.log("\n3. Attempting to execute distribution with outdated holders array...");
        
        vm.prank(executor);
        vm.expectRevert(IPaymentManager.IncompleteHoldersList.selector);
        paymentManager.distributeRevenue(address(0), 5 ether, holdersAtProposalTime);
        
        console.log("   [SUCCESS] Distribution REVERTED with IncompleteHoldersList error!");
        console.log("\n=== Vulnerability Confirmed ===");
        console.log("The distribution fails because:");
        console.log("- Holders array has 3 addresses totaling 1000 tokens");
        console.log("- But total supply is now 1100 tokens (new holder has 100)");
        console.log("- The check 'totalHoldersBalance != totalWeight' fails (1000 != 1100)");
    }
    
    function test_VulnerabilityTransferAfterProposalCreation() public {
        console.log("=== Testing Transfer to Non-Holder Scenario ===");
        
        // Step 1: Create proposal with current holders array
        address[] memory holdersAtProposalTime = new address[](3);
        holdersAtProposalTime[0] = alice;
        holdersAtProposalTime[1] = bob;
        holdersAtProposalTime[2] = charlie;
        
        console.log("1. Proposal created with 3 holders");
        console.log("   Total supply: %s", revenueShareToken.totalSupply());
        
        // Step 2: After proposal creation, charlie transfers tokens to address not in holder list
        address notInList = address(0xdead);
        uint256 charlieBalance = revenueShareToken.balanceOf(charlie);
        vm.prank(charlie);
        revenueShareToken.transfer(notInList, charlieBalance);
        
        console.log("\n2. Charlie transfers all tokens to address(0xdead) after proposal:");
        console.log("   - Charlie balance: %s", revenueShareToken.balanceOf(charlie));
        console.log("   - 0xdead balance: %s", revenueShareToken.balanceOf(notInList));
        console.log("   - Total supply unchanged: %s", revenueShareToken.totalSupply());
        
        // Step 3: Try to execute distribution - will fail because 0xdead is not in holders array
        console.log("\n3. Attempting distribution with outdated holders array...");
        
        vm.prank(executor);
        vm.expectRevert(IPaymentManager.IncompleteHoldersList.selector);
        paymentManager.distributeRevenue(address(0), 5 ether, holdersAtProposalTime);
        
        console.log("   [SUCCESS] Distribution REVERTED!");
        console.log("   The holders array has balances totaling 800 tokens");
        console.log("   But total supply is still 1000 (200 now held by 0xdead)");
    }
    
    function test_WorkaroundWithUpdatedHolders() public {
        console.log("=== Testing Workaround ===");
        
        // Initial state with new holder minted
        revenueShareToken.mint(newHolder, 100 * 1e18);
        
        // Create holders array that includes ALL current holders
        address[] memory allHolders = new address[](4);
        allHolders[0] = alice;
        allHolders[1] = bob;
        allHolders[2] = charlie;
        allHolders[3] = newHolder;
        
        console.log("Using updated holders array with all 4 holders");
        console.log("Total supply: %s", revenueShareToken.totalSupply());
        
        uint256 aliceBalBefore = alice.balance;
        uint256 bobBalBefore = bob.balance;
        uint256 charlieBalBefore = charlie.balance;
        uint256 newHolderBalBefore = newHolder.balance;
        
        vm.prank(executor);
        paymentManager.distributeRevenue(address(0), 5.5 ether, allHolders);
        
        console.log("\n[SUCCESS] Distribution succeeded with correct shares:");
        console.log("- Alice received: %s ETH (500/1100 * 5.5)", (alice.balance - aliceBalBefore) / 1e18);
        console.log("- Bob received: %s ETH (300/1100 * 5.5)", (bob.balance - bobBalBefore) / 1e18);
        console.log("- Charlie received: %s ETH (200/1100 * 5.5)", (charlie.balance - charlieBalBefore) / 1e18);
        console.log("- New holder received: %s ETH (100/1100 * 5.5)", (newHolder.balance - newHolderBalBefore) / 1e18);
    }
}